# Code

> Authors: Imen OULED-DLALA ([@dlalaimen](https://github.com/dlalaimen)), Said JABBOUR, Nicolas TRAVERS ([@chewbii](https://github.com/chewbii)) and Julien MARTIN-PRIN ([@Flexiboy](https://github.com/Flexiboy))

*This file explains what the codes do and how to run the apps*

## Master

The master parses the dataset and sends it, parsed, to mongoDB. Then it creates a guiding path vector and sends it to a kafka cluster. Then it waits for the models to be generated.

To run, the master needs few parameters:
* the minimum support
* the number of solvers
* the reset tag
* the dataset path

The minimum support must an int be between 1 and 10 000 000. The number of solvers must be an int between 1 and INT32_MAX. The reset tag must be 0 or 1 and decides wether or not the master needs to reset the database dataset (0 yes and 1 no). The dataset path is the path to the dataset.

Here is an example of how to use the master:

```bash
./master -minSupport=500 -nslovers=2 -reset=0 ../../../data/retail.dat
```

## Servant

The servant (or slave) push its config to mongoDB to indicate that it is ready to run and then retrieves the dataset config (number of items, transactions, etc...). It then wait the dataset to be completely pushed to mongoDB to retrieve it. After it has retrieved the dataset, the solver connects to a kafka cluster and then waits for its guiding path. It then generates models with all the data. After all the models has been generated, it pushes its generated models and its statistics (processing time of each guiding path) on the database.

To run, the servant needs few parameters:
* the minimum support
* the number of cores

The minimum support must be an interger between 1 and 10 000 000. The number of cores must be an int between 1 and your machine's capacity.

Here is an example of how to use the solver:
```bash
./slave -minSupport=500 -ncores=2
```

## Checking

The checking is just a simple script that verifies that the generated models are valid. It compares the file generated by the master to a file generated by the previous parallel solver.